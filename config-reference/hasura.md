# hasura

This is an optional section used by DipDup executor to automatically configure Hasura engine to track your tables.

```yaml
hasura:
  url: http://hasura:8080
  admin_secret: ${HASURA_ADMIN_SECRET:-changeme}
```

Under the hood DipDup generates Hasura metadata file out from your DB schema and accesses Hasura instance using [admin API](https://hasura.io/docs/latest/graphql/core/api-reference/metadata-api/index.html) endpoint.

Metadata configuration is idempotent: each time you do `dipdup run` it queries the existing schema and do the merge if required.

### Schema limitation

The current version of Hasura GraphQL Engine treats `public` and other schemas differently. Table `schema.customer` becomes `schema_customer` root field \(or `schemaCustomer` if `camel_case` option is enabled in DipDup config\). Table `public.customer` becomes `customer` field, without schema prefix. There's no way to remove this prefix for now. You can track related [issue \(opens new window\)](https://github.com/hasura/graphql-engine/issues/5394)at Hasura's GitHub to know when the situation will change. Since 3.0.0-rc1 DipDup enforces `public` schema to avoid ambiguity and issues with the GenQL library. You can still use any schema name if Hasura integration is not enabled.

### Authentication

DipDup sets READ only permissions for all tables and enables non-authorized access to the `/graphql` endpoint.

### Limit number of rows

DipDup creates `user` role allowed to perform queries without authorization. Now you can limit the maximum number of rows such queries return and also disable aggregation queries automatically generated by Hasura:

```yaml
hasura:
  select_limit: 100
```

Note that with limits enabled you have to use either offset or cursor-based [pagination](../client-side/#pagination) on the client side.

### Disable aggregation queries

```yaml
hasura:
  allow_aggregations: False
```

### Convert field names to camel case

For those of you from JavaScript world, it may be more familiar to use _camelCase_ for variable names instead of _snake\_case_ Hasura uses by default. DipDup now allows to convert all fields in metadata to this casing:

```yaml
hasura:
  camel_case: true
```

Now this example query to hic et nunc demo indexer...

```graphql
query MyQuery {
  hic_et_nunc_token(limit: 1) {
    id
    creator_id
  }
}
```

...will become this one:

```graphql
query MyQuery {
  hicEtNuncToken(limit: 1) {
    id
    creatorId
  }
}
```

All fields auto generated by Hasura will be renamed accordingly: `hic_et_nunc_token_by_pk` to `hicEtNuncTokenByPk`, `delete_hic_et_nunc_token` to `deleteHicEtNuncToken` and so on. To return to defaults, set `camel_case` to False and run `hasura configure` again.

### REST endpoints

One of the most anticipated features of Hasura 2.0 is the ability to expose arbitrary GraphQL queries as REST endpoints. By default, DipDup will generate GET and POST endpoints to fetch rows by primary key for all tables:

```javascript
$ curl http://127.0.0.1:8080/api/rest/hicEtNuncHolder?address=tz1UBZUkXpKGhYsP5KtzDNqLLchwF4uHrGjw
{
  "hicEtNuncHolderByPk": {
    "address": "tz1UBZUkXpKGhYsP5KtzDNqLLchwF4uHrGjw"
  }
}
```

However, there's a limitation dictated by the way Hasura parses HTTP requests: only models with primary keys of basic types \(int, string and so on\) can be fetched with GET requests. An attempt to fetch model with BIGINT primary key will lead to error: `Expected bigint for variable id got Number`.
A workaround to fetching any model is to send a POST request containing a JSON payload with a single key:

```javascript
$ curl -d '{"id": 152}' http://127.0.0.1:8080/api/rest/hicEtNuncToken
{
  "hicEtNuncTokenByPk": {
    "creatorId": "tz1UBZUkXpKGhYsP5KtzDNqLLchwF4uHrGjw",
    "id": 152,
    "level": 1365242,
    "supply": 1,
    "timestamp": "2021-03-01T03:39:21+00:00"
  }
}
```

We hope to get rid of this limitation someday and will let you know as soon as it happens.

Now the interesting part. You can put any number of `.graphql` files into `graphql` directory in your project's root, and DipDup will create REST endpoints for each of those queries. Let's say we want to fetch not only a specific token, but also the number of all tokens minted by its creator:

```graphql
query token_and_mint_count($id: bigint) {
  hicEtNuncToken(where: {id: {_eq: $id}}) {
    creator {
      address
      tokens_aggregate {
        aggregate {
          count
        }
      }
    }
    id
    level
    supply
    timestamp
  }
}
```

Save this query as `graphql/token_and_mint_count.graphql` and run `dipdup configure-hasura`. Now this query is available via REST endpoint at `http://127.0.0.1:8080/api/rest/token_and_mint_count`.

You can also disable creation of REST endpoints in the config:

```yaml
hasura:
  rest: False
```
