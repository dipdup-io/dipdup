---
name: "Config"
title: "Config â€¢ DipDup Docs"
description: "Developing a DipDup indexer begins with creating a YAML config file. You can find a minimal example to start indexing on the Quickstart page."
block: "getting_started"
---

# Creating config

Developing a DipDup indexer begins with creating a YAML config file of a specific format. DipDup expect it to be located in the project root and named `dipdup.yaml`. However, you can provide any path with a `-c` CLI option.

## Structure

Config consists of multiple top-level mappings. In the table below they are grouped by sections for convenience, but in the config file, they can be in any order.

<!-- TODO: Merge with table -->

- **Header** used to identify the project and the version of the DipDup specification. All other fields in the config are optional.
- **Inventory** specifies contracts that need to be indexed, datasources to fetch data from, and the database to store data in.
- **Indexes** section contains index templates that will be used to index contract data.
- **Hooks** define functions that can be called manually or on schedule.
- **Integrations** are used to configure third-party services.
- **Miscellanous** options affect the behavior of the whole framework.

{{ #include include/config-toc.md }}

## Merging multiple files

DipDup allows you to customize the configuration for a specific environment or workflow. It works similarly to docker-compose anchors but only for top-level sections. If you want to override a nested property, you need to recreate a whole top-level section. To merge several DipDup config files, provide the `-c` command-line option multiple times:

```shell [Terminal]
dipdup -c dipdup.yaml -c configs/dipdup.sqlite.yaml run
```

Use `config export`{lang="sh"} and `config env`{lang="sh"} commands to check the resulting config used by DipDup.

## Environment variables

DipDup supports compose-style variable expansion with optional default value. Use this feature to store sensitive data outside of the configuration file and make your app fully declarative.

```yaml
database:
  kind: postgres
  host: ${POSTGRES_HOST:-localhost}
  password: ${POSTGRES_PASSWORD}
```

You can use environment variables anywhere throughout the configuration file. Consider the following example (absolutely useless but illustrative):

```yaml
custom:
  ${FOO}: ${BAR:-bar}
  ${FIZZ:-fizz}: ${BUZZ}
```

Running `FOO=foo BUZZ=buzz dipdup config export --unsafe`{lang="sh"} will produce the following output:

```yaml
custom:
  foo: bar
  fizz: buzz
```
